import numpy as np

"""
[벡터의 유사도 구하기]
- 벡터의 유사도를 구하기 위한 방법으로는 이전에 설명한 코사인 유사도 외에도 여러가지 방법들이 있습니다.

(유클리드 거리(Euclidean distance))
- 유클리드 거리(euclidean distance)는 가장 기본적인 거리 공식입니다.
    평면 좌표계에서 (x1, y1) 점과 (x2, y2) 점 좌표간 거리를 구할 때를 생각해봅시다.
    삼각형 빗변을 구하는 피타고라스 정리 공식에 따라,

    빗변의 길이 ** 2 = ((x2 - x1) ** 2) + (y2 - y1) ** 2

    이 됩니다.
    여기에 루트만 씌워준다면 거리가 구해지게 되죠.
    좌표간 거리가 바로 2차원 벡터의 거리입니다.

    차원 수를 늘려서, 다차원 공간에서 두개의 벡터 p 와 q가 각각 p = (p1, p2, p3, p4, ..., pn)과 q = (q1, q2, q3, q4, ..., qn) 라고 할 때,
    두 벡터 사이의 거리를 계산하는 유클리드 거리 공식은 다음과 같습니다.

    sqrt(sum((p - q)** 2))

- 위와 같이 간단하고 명료하지만, 유클리드 거리(euclidean distance)는 자연어 벡터의 유사도를 구할 때 자카드 유사도나 코사인 유사도만큼, 유용한 방법은 아닙니다.
"""


# (유클리드 거리 구현)
def dist(x, y):
    return np.sqrt(np.sum((x - y) ** 2))


doc1 = np.array((2, 3, 0, 1))
doc2 = np.array((1, 1, 0, 1))

print('문서1과 문서2의 거리 :', dist(doc1, doc2))

"""
(코사인 유사도(Cosine Similarity))
- 전에 설명하였지만, 유사도를 구하는 방법을 정리하고 있으니, 코드없이 정리합니다.
    코사인 유사도는 두 벡터 간의 코사인 각도를 이용하여 구할 수 있는 두 벡터의 유사도를 의미합니다.
    두 벡터의 방향이 완전히 동일한 경우에는 1의 값을 가지며,
    90°의 각을 이루면 0, 180°로 반대의 방향을 가지면 -1의 값을 갖게 됩니다.
    즉, 결국 코사인 유사도는 -1 이상 1 이하의 값을 가지며 값이 1에 가까울수록 유사도가 높다고 판단할 수 있습니다.
    이를 직관적으로 이해하면 두 벡터가 가리키는 방향이 얼마나 유사한가를 의미합니다.

- 수식으로 나타내면,
    (A * B) / (||A|| * ||B||)
    입니다.
    분자의 (A * B) 는 A 벡터와 B 벡터를 dot product 하는 것이고,
    분모의 (||A|| * ||B||) 은 A 의 norm 과 B 의 norm 을 곱하는 것으로,
    norm 은 이전에 loss regularization 에서 설명했기에 생략합니다.
"""

"""
(자카드 유사도(Jaccard similarity))
"""
